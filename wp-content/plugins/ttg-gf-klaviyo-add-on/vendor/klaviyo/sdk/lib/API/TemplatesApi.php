<?php
/**
 * TemplatesApi
 * PHP version 7.3
 *
 * @category Class
 * @package  Klaviyo
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Klaviyo API
 *
 * Empowering creators to own their destiny
 *
 * The version of the OpenAPI document: 2022.03.29
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Klaviyo\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Klaviyo\ApiException;
use Klaviyo\Configuration;
use Klaviyo\HeaderSelector;
use Klaviyo\ObjectSerializer;

/**
 * TemplatesApi Class Doc Comment
 *
 * @category Class
 * @package  Klaviyo
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TemplatesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cloneTemplate
     *
     * Clone Template
     *
     * @param  string $template_id template_id (required)
     * @param  string $name The new name of the email template. (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function cloneTemplate($template_id, $name)
    {
        list($response) = $this->cloneTemplateWithHttpInfo($template_id, $name);
        return $response;
    }

    /**
     * Operation cloneTemplateWithHttpInfo
     *
     * Clone Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloneTemplateWithHttpInfo($template_id, $name)
    {
        $request = $this->cloneTemplateRequest($template_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloneTemplateAsync
     *
     * Clone Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneTemplateAsync($template_id, $name)
    {
        return $this->cloneTemplateAsyncWithHttpInfo($template_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloneTemplateAsyncWithHttpInfo
     *
     * Clone Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloneTemplateAsyncWithHttpInfo($template_id, $name)
    {
        $returnType = 'array<string,mixed>';
        $request = $this->cloneTemplateRequest($template_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloneTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloneTemplateRequest($template_id, $name)
    {
        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling cloneTemplate'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling cloneTemplate'
            );
        }

        $resourcePath = '/v1/email-template/{template_id}/clone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTemplate
     *
     * Create New Template
     *
     * @param  string $name The name of the email template. (required)
     * @param  string $html html (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function createTemplate($name, $html)
    {
        list($response) = $this->createTemplateWithHttpInfo($name, $html);
        return $response;
    }

    /**
     * Operation createTemplateWithHttpInfo
     *
     * Create New Template
     *
     * @param  string $name The name of the email template. (required)
     * @param  string $html (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTemplateWithHttpInfo($name, $html)
    {
        $request = $this->createTemplateRequest($name, $html);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTemplateAsync
     *
     * Create New Template
     *
     * @param  string $name The name of the email template. (required)
     * @param  string $html (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateAsync($name, $html)
    {
        return $this->createTemplateAsyncWithHttpInfo($name, $html)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTemplateAsyncWithHttpInfo
     *
     * Create New Template
     *
     * @param  string $name The name of the email template. (required)
     * @param  string $html (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTemplateAsyncWithHttpInfo($name, $html)
    {
        $returnType = 'array<string,mixed>';
        $request = $this->createTemplateRequest($name, $html);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTemplate'
     *
     * @param  string $name The name of the email template. (required)
     * @param  string $html (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTemplateRequest($name, $html)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling createTemplate'
            );
        }
        // verify the required parameter 'html' is set
        if ($html === null || (is_array($html) && count($html) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $html when calling createTemplate'
            );
        }

        $resourcePath = '/v1/email-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($html !== null) {
            $formParams['html'] = ObjectSerializer::toFormValue($html);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTemplate
     *
     * Delete Template
     *
     * @param  string $template_id template_id (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function deleteTemplate($template_id)
    {
        list($response) = $this->deleteTemplateWithHttpInfo($template_id);
        return $response;
    }

    /**
     * Operation deleteTemplateWithHttpInfo
     *
     * Delete Template
     *
     * @param  string $template_id (required)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTemplateWithHttpInfo($template_id)
    {
        $request = $this->deleteTemplateRequest($template_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTemplateAsync
     *
     * Delete Template
     *
     * @param  string $template_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsync($template_id)
    {
        return $this->deleteTemplateAsyncWithHttpInfo($template_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTemplateAsyncWithHttpInfo
     *
     * Delete Template
     *
     * @param  string $template_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplateAsyncWithHttpInfo($template_id)
    {
        $returnType = 'array<string,mixed>';
        $request = $this->deleteTemplateRequest($template_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTemplate'
     *
     * @param  string $template_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTemplateRequest($template_id)
    {
        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling deleteTemplate'
            );
        }

        $resourcePath = '/v1/email-template/{template_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTemplates
     *
     * Get All Templates
     *
     * @param  int $page For pagination, which page of results to return. Default &#x3D; 0 (optional, default to 0)
     * @param  int $count For pagination, the number of results to return. Max &#x3D; 100 (optional, default to 50)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function getTemplates($page = 0, $count = 50)
    {
        list($response) = $this->getTemplatesWithHttpInfo($page, $count);
        return $response;
    }

    /**
     * Operation getTemplatesWithHttpInfo
     *
     * Get All Templates
     *
     * @param  int $page For pagination, which page of results to return. Default &#x3D; 0 (optional, default to 0)
     * @param  int $count For pagination, the number of results to return. Max &#x3D; 100 (optional, default to 50)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTemplatesWithHttpInfo($page = 0, $count = 50)
    {
        $request = $this->getTemplatesRequest($page, $count);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTemplatesAsync
     *
     * Get All Templates
     *
     * @param  int $page For pagination, which page of results to return. Default &#x3D; 0 (optional, default to 0)
     * @param  int $count For pagination, the number of results to return. Max &#x3D; 100 (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsync($page = 0, $count = 50)
    {
        return $this->getTemplatesAsyncWithHttpInfo($page, $count)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTemplatesAsyncWithHttpInfo
     *
     * Get All Templates
     *
     * @param  int $page For pagination, which page of results to return. Default &#x3D; 0 (optional, default to 0)
     * @param  int $count For pagination, the number of results to return. Max &#x3D; 100 (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTemplatesAsyncWithHttpInfo($page = 0, $count = 50)
    {
        $returnType = 'array<string,mixed>';
        $request = $this->getTemplatesRequest($page, $count);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTemplates'
     *
     * @param  int $page For pagination, which page of results to return. Default &#x3D; 0 (optional, default to 0)
     * @param  int $count For pagination, the number of results to return. Max &#x3D; 100 (optional, default to 50)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTemplatesRequest($page = 0, $count = 50)
    {
        if ($page !== null && $page < 0) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling TemplatesApi.getTemplates, must be bigger than or equal to 0.');
        }

        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling TemplatesApi.getTemplates, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling TemplatesApi.getTemplates, must be bigger than or equal to 1.');
        }


        $resourcePath = '/v1/email-templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            if('form' === 'form' && is_array($page)) {
                foreach($page as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['page'] = $page;
            }
        }
        // query params
        if ($count !== null) {
            if('form' === 'form' && is_array($count)) {
                foreach($count as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['count'] = $count;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renderTemplate
     *
     * Render Template
     *
     * @param  string $template_id template_id (required)
     * @param  string $context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function renderTemplate($template_id, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        list($response) = $this->renderTemplateWithHttpInfo($template_id, $context);
        return $response;
    }

    /**
     * Operation renderTemplateWithHttpInfo
     *
     * Render Template
     *
     * @param  string $template_id (required)
     * @param  string $context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function renderTemplateWithHttpInfo($template_id, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        $request = $this->renderTemplateRequest($template_id, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation renderTemplateAsync
     *
     * Render Template
     *
     * @param  string $template_id (required)
     * @param  string $context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderTemplateAsync($template_id, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        return $this->renderTemplateAsyncWithHttpInfo($template_id, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renderTemplateAsyncWithHttpInfo
     *
     * Render Template
     *
     * @param  string $template_id (required)
     * @param  string $context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renderTemplateAsyncWithHttpInfo($template_id, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        $returnType = 'array<string,mixed>';
        $request = $this->renderTemplateRequest($template_id, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renderTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $context This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renderTemplateRequest($template_id, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling renderTemplate'
            );
        }

        $resourcePath = '/v1/email-template/{template_id}/render';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }

        // form params
        if ($context !== null) {
            $formParams['context'] = ObjectSerializer::toFormValue($context);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendTemplate
     *
     * Render and Send Template
     *
     * @param  string $template_id template_id (required)
     * @param  string $from_email from_email (required)
     * @param  string $from_name from_name (required)
     * @param  string $subject subject (required)
     * @param  string $to **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; (required)
     * @param  string $context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function sendTemplate($template_id, $from_email, $from_name, $subject, $to, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        list($response) = $this->sendTemplateWithHttpInfo($template_id, $from_email, $from_name, $subject, $to, $context);
        return $response;
    }

    /**
     * Operation sendTemplateWithHttpInfo
     *
     * Render and Send Template
     *
     * @param  string $template_id (required)
     * @param  string $from_email (required)
     * @param  string $from_name (required)
     * @param  string $subject (required)
     * @param  string $to **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; (required)
     * @param  string $context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendTemplateWithHttpInfo($template_id, $from_email, $from_name, $subject, $to, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        $request = $this->sendTemplateRequest($template_id, $from_email, $from_name, $subject, $to, $context);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendTemplateAsync
     *
     * Render and Send Template
     *
     * @param  string $template_id (required)
     * @param  string $from_email (required)
     * @param  string $from_name (required)
     * @param  string $subject (required)
     * @param  string $to **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; (required)
     * @param  string $context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendTemplateAsync($template_id, $from_email, $from_name, $subject, $to, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        return $this->sendTemplateAsyncWithHttpInfo($template_id, $from_email, $from_name, $subject, $to, $context)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendTemplateAsyncWithHttpInfo
     *
     * Render and Send Template
     *
     * @param  string $template_id (required)
     * @param  string $from_email (required)
     * @param  string $from_name (required)
     * @param  string $subject (required)
     * @param  string $to **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; (required)
     * @param  string $context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendTemplateAsyncWithHttpInfo($template_id, $from_email, $from_name, $subject, $to, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        $returnType = 'array<string,mixed>';
        $request = $this->sendTemplateRequest($template_id, $from_email, $from_name, $subject, $to, $context);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $from_email (required)
     * @param  string $from_name (required)
     * @param  string $subject (required)
     * @param  string $to **Mixed**. string, or JSON encoded array of objects with \\\&quot;email\\\&quot; and \\\&quot;name\\\&quot; keys. &#x60;abraham.lincoln@klaviyo.com&#x60; OR &#x60;[{\\\&quot;name\\\&quot;:\\\&quot;Abraham Lincoln\\\&quot;,\\\&quot;email\\\&quot;:\\\&quot;abraham.lincoln@klaviyo.com\\\&quot;}]&#x60; (required)
     * @param  string $context Optional, JSON object. This is the context your email template will be rendered with. Email templates are rendered with contexts in a similar manner to how Django templates are rendered. This means that nested template variables can be referenced via dot notation and template variables without corresponding context values are treated as falsy and output nothing. ex: &#x60;{ \\\&quot;name\\\&quot; : \\\&quot;George Washington\\\&quot;, \\\&quot;state\\\&quot; : \\\&quot;VA\\\&quot; }&#x60; (optional, default to '{ "name" : "George Washington", "state" : "VA" }')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendTemplateRequest($template_id, $from_email, $from_name, $subject, $to, $context = '{ "name" : "George Washington", "state" : "VA" }')
    {
        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling sendTemplate'
            );
        }
        // verify the required parameter 'from_email' is set
        if ($from_email === null || (is_array($from_email) && count($from_email) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_email when calling sendTemplate'
            );
        }
        // verify the required parameter 'from_name' is set
        if ($from_name === null || (is_array($from_name) && count($from_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $from_name when calling sendTemplate'
            );
        }
        // verify the required parameter 'subject' is set
        if ($subject === null || (is_array($subject) && count($subject) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $subject when calling sendTemplate'
            );
        }
        // verify the required parameter 'to' is set
        if ($to === null || (is_array($to) && count($to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $to when calling sendTemplate'
            );
        }

        $resourcePath = '/v1/email-template/{template_id}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }

        // form params
        if ($from_email !== null) {
            $formParams['from_email'] = ObjectSerializer::toFormValue($from_email);
        }
        // form params
        if ($from_name !== null) {
            $formParams['from_name'] = ObjectSerializer::toFormValue($from_name);
        }
        // form params
        if ($subject !== null) {
            $formParams['subject'] = ObjectSerializer::toFormValue($subject);
        }
        // form params
        if ($to !== null) {
            $formParams['to'] = ObjectSerializer::toFormValue($to);
        }
        // form params
        if ($context !== null) {
            $formParams['context'] = ObjectSerializer::toFormValue($context);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTemplate
     *
     * Update Template
     *
     * @param  string $template_id template_id (required)
     * @param  string $name The new name of the email template. (optional)
     * @param  string $html The new HTML content for this template. (optional)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array<string,mixed>
     */
    public function updateTemplate($template_id, $name = null, $html = null)
    {
        list($response) = $this->updateTemplateWithHttpInfo($template_id, $name, $html);
        return $response;
    }

    /**
     * Operation updateTemplateWithHttpInfo
     *
     * Update Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (optional)
     * @param  string $html The new HTML content for this template. (optional)
     *
     * @throws \Klaviyo\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of array<string,mixed>, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTemplateWithHttpInfo($template_id, $name = null, $html = null)
    {
        $request = $this->updateTemplateRequest($template_id, $name, $html);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('array<string,mixed>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    $parsed_content = json_decode($content, TRUE);
                    if (json_last_error() != JSON_ERROR_NONE) {
                        $parsed_content = $content;
                    }

                    return [
                        $parsed_content,
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'array<string,mixed>';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            $parsed_content = json_decode($content, TRUE);
            if (json_last_error() != JSON_ERROR_NONE) {
                $parsed_content = $content;
            }


            return [
                $parsed_content,
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,mixed>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTemplateAsync
     *
     * Update Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (optional)
     * @param  string $html The new HTML content for this template. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsync($template_id, $name = null, $html = null)
    {
        return $this->updateTemplateAsyncWithHttpInfo($template_id, $name, $html)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTemplateAsyncWithHttpInfo
     *
     * Update Template
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (optional)
     * @param  string $html The new HTML content for this template. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTemplateAsyncWithHttpInfo($template_id, $name = null, $html = null)
    {
        $returnType = 'array<string,mixed>';
        $request = $this->updateTemplateRequest($template_id, $name, $html);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTemplate'
     *
     * @param  string $template_id (required)
     * @param  string $name The new name of the email template. (optional)
     * @param  string $html The new HTML content for this template. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTemplateRequest($template_id, $name = null, $html = null)
    {
        // verify the required parameter 'template_id' is set
        if ($template_id === null || (is_array($template_id) && count($template_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_id when calling updateTemplate'
            );
        }

        $resourcePath = '/v1/email-template/{template_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($template_id !== null) {
            $resourcePath = str_replace(
                '{' . 'template_id' . '}',
                ObjectSerializer::toPathValue($template_id),
                $resourcePath
            );
        }

        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($html !== null) {
            $formParams['html'] = ObjectSerializer::toFormValue($html);
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/x-www-form-urlencoded']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('api_key');
        if ($apiKey !== null) {
            $queryParams['api_key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
